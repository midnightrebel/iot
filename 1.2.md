# 1.2 Лабораторная работа: входы и выходы микроконтроллера
## 1.2.1 Управление внешним устройством на примере реле
В этом практикуме предлагается поработать с GPIO (General Purpose Input/Output — порты ввода-вывода общего назначения). GPIO позволяют соединять микроконтроллер с внешними устройствами по максимально простому интерфейсу: наличие либо отсутствие сигнала.

Задача: пощелкать не встроенным светодиодом, а внешним реле, подключенным к плате.
Для этого задания понадобятся:

* Плата STM32Nucleo

![new1](https://lh5.googleusercontent.com/yZAxmUvRdvbyt-8zNT60TDRbwurrP53nV0ahrueqlRAIHglZee0d5tSAaazq5fxFlAHgVeRZ8LjcrBnjzdSLzmvwmDyr5mcaf9ZEUhyZjBuhs_6I13vgAKMhqrfocTT_bDwVBBHp)

* Плата-переходник - Slot Shield (либо Grove Shield)

![new2](https://lh5.googleusercontent.com/NFVbXvdCbDkDN0FsptCoz9NUmg-A6V2_xzt8QqucLDPxlzw8zYfzPBOKSwDFSxaK_akIJ-FfGPhmyrrBkQLkHES4gzgm0t90LJECZpx5W4Gkm59QeCh-J-jRxskMaQDli-ThHWWO)

* Модуль реле (Амперка либо Grove)

![new3](https://lh6.googleusercontent.com/CJGHJVNT3WRnGQXF0TzAGWGxxtXSdjdjBKFHQoWNfMey4SRet9FV7RkD9NhPOm-GcLbZLTStSzba4Cyq_Vl_P1mWHsBJ5zWSx9M8vnvqb5xitAH-mYYLwWfFZEu0qBb06TX25Bh2)

У микроконтроллера на учебной отладочной плате есть достаточно много свободных выводов, распоряжаться которыми можно по своему желанию.

Свободные выводы можно конфигурировать и использовать как:

* выходы (отправлять на них “высокий” или “низкий” логический уровень, то есть устанавливать напряжение 3,3 В или сбрасывать в ноль)
* входы (считывать их состояние)

Что здесь важно знать: не все выводы можно задействовать. К примеру, выводы D0 и D1 задействовать не рекомендуется, так как они уже заняты отладочной консолью. D0, D1 и так далее пронумерованы так только на самой плате (маленькие номера у каждого вывода). Выводы же с точки зрения микроконтроллера называются иначе - они сгруппированы в порты (PORT, или просто P), и в рамках каждого порта пронумерованы (например, PA_6, на плате этот вывод подписан как 12). Есть даже третья нумерация - это абсолютная нумерация выводов микросхемы, то есть просто по номерам, без всяких букв.

![new4](https://lh5.googleusercontent.com/ZUeZ1Rq-0aNjPxP59KiclR_uqs8T5C8vsUJ2EIGof7qbNW6VkiCZsZflCjPiddIPHmoBLjUZ-_11cSRtOUbMtuZ_-QnjlBAG4kv9a25hbiGVL2mZGRsqNvBWn8uahD1fAvpJzzHg)

Подключение реле будет через плату-переходник (это может быть Slot Shield или Grove Base Shield).

## 1.2.2 Считывание нажатия кнопки

Для этого задания понадобятся:

* Плата STM32Nucleo

![new1](https://lh5.googleusercontent.com/yZAxmUvRdvbyt-8zNT60TDRbwurrP53nV0ahrueqlRAIHglZee0d5tSAaazq5fxFlAHgVeRZ8LjcrBnjzdSLzmvwmDyr5mcaf9ZEUhyZjBuhs_6I13vgAKMhqrfocTT_bDwVBBHp)

Снизу пример кода,который позволяет считать нажатие кнопки. Для негопонадобится только плата Nucleo, а считывать нажатие будет происходить у встроенной в плату синей кнопки, она здесь называется USER_BUTTON.
```C
#include "mbed.h"
 
DigitalIn mybutton(USER_BUTTON);
DigitalOut myled(LED1);

int main()
{
    mybutton.mode(PullUp);

    while(1) {
        printf("Button state is: %d\n\r", mybutton.read());

        if (mybutton == 0) { // Button is pressed

            myled = !myled; // Toggle the LED state
            wait_ms(200); // 200 ms
        }
    }
}
```
В этом коде нуждается в пояснении строчка:
```C
mybutton.mode(PullUp);
```
Этой инструкцией включается подтягивающий резистор.Подтягивающий резистор — резистор, включённый между проводником, по которому распространяется электрический сигнал, и питанием (pull-up resistor — подтягивающий вверх/подтягивающий к питанию резистор), либо между проводником и землёй (pull-down resistor — подтягивающий вниз/подтягивающий к земле/стягивающий резистор).

## 1.2.3 Выдача ШИМ-сигнала с платы

Для управления яркостью светодиода будет использоваться широтно-импульсная модуляция(ШИМ). Это означает, что вместо непрерывной подачи напряжения это происходит с перерывами, за счет чего общая яркость свечения будет ниже. Перерывов человеческий глаз не заметит, поскольку будет очень большая скорость переключения.

Для этого задания вам понадобится:

* Плата STM32Nucleo

![new1](https://lh5.googleusercontent.com/yZAxmUvRdvbyt-8zNT60TDRbwurrP53nV0ahrueqlRAIHglZee0d5tSAaazq5fxFlAHgVeRZ8LjcrBnjzdSLzmvwmDyr5mcaf9ZEUhyZjBuhs_6I13vgAKMhqrfocTT_bDwVBBHp)

В mbed всё, что касается ШИМ, инкапсулировано в библиотеке PwmOut.
Пример кода:
```C
#include "mbed.h"

PwmOut PWM1(LED1);

int main()
{
    PWM1.period(0.010); // set PWM period to 10 ms
    PWM1=0.5; // set duty cycle to 50%
}
```

Пример для управления яркостью светодиода с клавиатуры:

```C
#include "mbed.h"
Serial pc(USBTX, USBRX); // tx, rx
PwmOut led(LED1);
float brightness=0.0;

int main()
{
    pc.printf("Control of LED dimmer by host terminal\n\r");
    pc.printf("Press 'u' = brighter, 'd' = dimmer\n\r");

    while(1) {
        char c = pc.getc();
        wait(0.001);
        if((c == 'u') && (brightness < 0.1)) {
            brightness += 0.001;
            led = brightness;
        }

        if((c == 'd') && (brightness > 0.0)) {
            brightness -= 0.001;
            led = brightness;
        }
        pc.printf("%c %1.3f \n \r",c,brightness);
    }
}
```
Здесь может возникнуть вопрос, зачем создавать объект типа Serial. Ответ на него из него складывается из того,что привычные всем из C функции getc, putc, в mbed реализованы как методы класса Serial, и если попробовать вызвать их без этого, то будет ошибка компиляции.

## 1.2.4 Подключение кнопочной клавиатуры
Для этого задания понадобится:

* Плата STM32Nucleo

![new1](https://lh5.googleusercontent.com/yZAxmUvRdvbyt-8zNT60TDRbwurrP53nV0ahrueqlRAIHglZee0d5tSAaazq5fxFlAHgVeRZ8LjcrBnjzdSLzmvwmDyr5mcaf9ZEUhyZjBuhs_6I13vgAKMhqrfocTT_bDwVBBHp)

Важно! Здесь подходят не все модели. Было экспериментально замечено, что на некоторых платах, например L053R8 или L073RZ, при выполнении данного примера происходит сброс контроллера.

* Плата-переходник - Slot Shield (либо Grove Shield)

![new2](https://lh5.googleusercontent.com/NFVbXvdCbDkDN0FsptCoz9NUmg-A6V2_xzt8QqucLDPxlzw8zYfzPBOKSwDFSxaK_akIJ-FfGPhmyrrBkQLkHES4gzgm0t90LJECZpx5W4Gkm59QeCh-J-jRxskMaQDli-ThHWWO)

* Кнопочный модуль

![new5](https://lh5.googleusercontent.com/l-oFHRGR1z2rJhUu-V2E_wR_MV3oUJWIbZXZsDu643RlsUU-5IP1YfzYj3-n99Kadd8WYa3EV7fuKlQm-82il2piK4y-J-RFF-mAmNHEturm6z6K-gVGmD73je6z6-G2_FmHFsU-)

Для выполнения задания Кейса понадобится клавиатурный модуль. Он устроен чрезвычайно просто, и подойдет от любого производителя. Даже если нет Slot Shield, всегда можно использовать любую другую клавиатуру или даже просто разместить на макетной плате четыре отдельные кнопки.

Как правильно подключить этот модуль: выводы V (питание) и G (земля) должны совпасть с соответствующими выводами на плате Slot Shield, а выводы S1, S2, S3 и S4 - с любыми входами/выходами на плате.


Если посмотреть на Slot Shield, то быстро становится понятно, что модуль клавиатуры можно вставить в один из трех слотов: A, B или C, причем повернутым на 90 градусов против часовой стрелки. 



| Кнопка        | Вывод платы Nucleo |
| --- |:---:|
| S1 | A4|
| S2 | A5|
| S3 | D2|
| S4 | D7| 

Работа с этим модулем совершенно аналогична работе с одной кнопкой, за одним исключением: в модуль уже впаяны подтягивающие резисторы, поэтому включать их в коде явным образом не нужно.Создаётся режим PullNone, чтобы это обозначить и не задействовать встроенный подтягивающий резистор.

Пример считывания нажатия кнопки на порте D7.
```C
#include "mbed.h"

DigitalIn mybutton(D7);
DigitalOut myled(LED1);

int main() {

  mybutton.mode(PullNone);

  while(1) {

    printf("Button state is: %d\n\r", mybutton.read());

    if (mybutton == 0) { // Button is pressed

      myled = !myled; // Toggle the LED state
      wait(0.2); // 200 ms
    }
  }
}
```
